name: ArrayRobot

physics_engine: 'physx'

dct:
  order: 3    # dim. of robot state = dim. of action = (order ** 2 + order) // 2
  step: 0.5   # step on the selected freq. per action
  dim_local: 5  # object-centric, local perception and action field

goal:
  pos: [0.0, 0.0, 0.0]
  ori: [0.0, 0.0, 0.0, 1.0]

reward:
  trans_diff_factor: 0.1
  trans_delta_diff_factor: 100
  reach_threshold: 0.02
  reach_bonus: 10

env:
  numEnvs: 4
  maxEpisodeLength: 200
  actionSpeedScale: 20

  # dimensions
  numObservations: 16   # [object] pos. (3), ori. (4), diff. of pos. from goal (3), [robot] dct desc. (6)
  numActions: 6   # dct desc. (6)

#  clipObservations: 5.0
#  clipActions: 1.0

  controlFrequencyInv: 5   # how many sim steps per RL step

  # customized settings

  robot:
    row_gap: 0.02
    velocity: 0.05
    stiffness: 4000.0
    damping: 200.0
    effort: 1000.0
  object:
    x: 0.16
    y: 0.16
    z: 0.01
  assets:
    robot:
      root: "TableBot/urdf"   # from ~ to file
      file: "tablebot_row_16.urdf"
    object:
      root: "TableBot/urdf"
      file: "ball.urdf"
      half_extend: 0.02   # TODO: automatically calculate

sim:
  dt: 0.01
  substeps: 2
  up_axis: "z"
  use_gpu_pipeline: False
  gravity: [0.0, 0.0, -9.81]
  physx:
    num_threads: 1
    solver_type: 1
    use_gpu: "cuda:0"
    num_position_iterations: 8
    num_velocity_iterations: 0
#    contact_offset: 0.02
#    rest_offset: 0.001
#    bounce_threshold_velocity: 0.2
#    max_depenetration_velocity: 1000.0
#    default_buffer_size_multiplier: 5.0
#    max_gpu_contact_pairs: 8388608 # 8*1024*1024
#    num_subscenes: ${....num_subscenes}
#    contact_collection: 0 # 0: CC_NEVER (don't collect contact info), 1: CC_LAST_SUBSTEP (collect only contacts on last substep), 2: CC_ALL_SUBSTEPS (broken - do not use!)
task:
  randomize: False
