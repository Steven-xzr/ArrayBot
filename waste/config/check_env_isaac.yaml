# used to create the object
name: ArrayRobot

num_envs: 4
dim_obs_obj: 10   # pos. (3), ori. (4), diff. of pos. from goal (3)
dim_local: 5  # object-centric, local perception and action field
max_episode_steps: 200

dct:
  order: 3    # dim. of robot state = dim. of action = (order ** 2 + order) // 2
  step: 0.5   # step on the selected freq. per action

goal:
  pos: [0.0, 0.0, 0.0]
  ori: [0.0, 0.0, 0.0, 1.0]

reward:
  trans_diff_factor: 0.1
  trans_delta_diff_factor: 100
  reach_threshold: 0.02
  reach_bonus: 10

env:
  robot:
    row_gap: 0.02
    velocity: 0.05
    stiffness: 4000.0
    damping: 200.0
    effort: 1000.0
  object:
    x: 0.16
    y: 0.16
    z: 0.01
  assets:
    robot:
      root: "TableBot/urdf"   # from ~ to file
      file: "tablebot_row_15.urdf"
    object:
      root: "TableBot/urdf"
      file: "ball.urdf"
      half_extend: 0.02   # TODO: automatically calculate

sim:
  headless: False
  dt: 0.05
  substeps: 2
  use_gpu_pipeline: False
  sim_device: "cuda:0"
  control_freq: 5   # how many sim steps per RL step
  physx:
    num_threads: 1
    solver_type: 1
    num_position_iterations: 8
    num_velocity_iterations: 0
    contact_offset: 0.02
    rest_offset: 0.001
#    bounce_threshold_velocity: 0.2
#    max_depenetration_velocity: 1000.0
#    default_buffer_size_multiplier: 5.0
#    max_gpu_contact_pairs: 8388608 # 8*1024*1024
#    num_subscenes: ${....num_subscenes}
#    contact_collection: 0 # 0: CC_NEVER (don't collect contact info), 1: CC_LAST_SUBSTEP (collect only contacts on last substep), 2: CC_ALL_SUBSTEPS (broken - do not use!)
task:
  randomize: False
